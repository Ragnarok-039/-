# Функция для поиска первой сломанной версии.
# Так как подразумевается, что версии идут друг за другом, на выходе получается отсортированный список версий.
# Данная задача реализована с помощью бинарного поиска, дабы уменьшить количество обращений к API.
# Худшая сложность в нотации O - (log n).


def solve(dict_status):
    # Если версия всего одна и она сломанная, возвращаем тут же первый индекс.
    if len(dict_status) == 1 and not dict_status[0]:
        return 0
    # Если версий больше, чем одна.
    else:
        # Определяем границы массива. Первый элемент - 0, последний равен длине массива минус 1.
        start, end = 0, len(dict_status) - 1
        # Условием выхода из цикла является ситуация, когда разность индексов будет <= 1.
        while abs(start - end) > 1:
            # Определяем середину массива.
            mid = (start + end) // 2
            # Если индекс от середины True, то все индексы левее середины тоже True.
            # Значит, они нам не интересны.
            # Устанавливаем старт == середине для следующей итерации.
            if dict_status[mid]:
                start = mid + 1
            # Иначе мы нашли False.
            # Соответственно, все индексы правее тоже False.
            # Они нам так же не интересны.
            # Устанавливаем правую границу массива == середине.
            else:
                end = mid
        # Выход из цикла - два оставшихся индекса.
        # Если один из индексов True, то необходимый нам False находится под другим индексом.
        if dict_status[start]:
            return end
        # Иначе индекс False. И он является необходимым нам.
        else:
            return start
